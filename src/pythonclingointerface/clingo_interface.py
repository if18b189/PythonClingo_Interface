import subprocess
import os
import tempfile
import glob

"""Solution Format"""


class ClingoSolutions:
    def __init__(self, clingoCode):
        if type(clingoCode == bytes):
            self.text = clingoCode
        if type(clingoCode == str):
            self.text = clingoCode
        self.solutions = []
        lines = self.text.splitlines()
        go = False
        for line in lines:
            if go:
                self.solutions.append([])
                """Parts of the solution can be accessed too. """
                for part in line.decode("utf-8").split(" "):
                    self.solutions[len(self.solutions) - 1].append(part)
                go = False
            """If it is an awnser, the next line will be saved as a Solution. """
            if "Answer" in line.decode("utf-8"):
                go = True
        self.text = self.text.decode("utf-8")







class ClingoProblem:
    def __init__(self, code=""):
        self.code=code
        self.solutions:ClingoSolutions
    def run(self):
        self.fd, self.temporaryFilePath = tempfile.mkstemp(suffix='.txt', prefix='clingoInterfaceTemp_', dir=os.getcwd(),
                                                 text=True)
        with os.fdopen(self.fd, "w") as tmp:
            self.clingoCodeContent = self.code.split("\n", 1)[1]
            tmp.write(self.clingoCodeContent)
        if self.code is not None:
            with tempfile.TemporaryFile() as tempf:  # reading into a temporary file prevents issues with bigger input values
                self.proc = subprocess.Popen('clingo ' + self.temporaryFilePath, shell=True, stdout=tempf)
                self.proc.wait()
                tempf.seek(0)
                self.solutions=ClingoSolutions(tempf.read())
        os.remove(self.temporaryFilePath)
"""Looking for Code"""


class ClingoInterface:
    def __init__(self):
        self.solutions = []
        self.problems=[]
        # ClingoInterface.jnotebookParenthesis(self)

    """
        calls executeClingoCode, can take lists of code or a single code file
    """

    def run(self, pathList_or_code):
        if type(pathList_or_code) is list:
            for path in pathList_or_code:
                self.executeClingoCode(path)
        else:
            self.executeClingoCode(pathList_or_code)

    """
        executes clingo code inside a subprocess(in a terminal) and adds the solutions to the ClingoSolutions Class
    """

    def executeClingoCode(self, code):
        if code is not None:
            with tempfile.TemporaryFile() as tempf:  # reading into a temporary file prevents issues with bigger input values
                proc = subprocess.Popen('clingo ' + code, shell=True, stdout=tempf)
                proc.wait()
                tempf.seek(0)
                self.solutions.append(ClingoSolutions(tempf.read()))
        else:
            print("ClingoInterface:Run(): there is no file to run")

    """
        printing ALL solutions generated by Run()->ClingoSolutions
    """

    def printSolutions(self):
        print(self.solutions)
        for i in self.solutions:
            print(i.text)
            print(i.solutions)

    """
        scans all folders and looks for a match with the given foldername
        if it finds the folder it returns the path
        example:
        findDirectory(test)
        absolutepath: C:\\Users\\USER\\test\\Project\\helloworld.txt
        returns: C:\\Users\\USER\\test\\
    """

    def findDirectory(self, foldername):
        sep = os.sep
        dirs = os.path.abspath("").split("\\")
        newdir = ""
        for d in dirs:
            newdir += d + sep
            if d == foldername:
                # print("newdir" + newdir)   #debug code
                return newdir

        raise Exception("ClingoInterface: findDirectory: couldnt find folder")

    """
        scanning all directories recursively for jupyter notebook files
        extracting the (clingo) code between 2 markers/parenthesis (perenthesis_start & parenthesis_end)
    """

    def jupyterParenthesis(self, directoryName="PythonClingo_Interface"):
        parenthesis = False
        parenthesis_start = "<CLINGO"
        parenthesis_end = "CLINGO>"
        parenthesis_content = ""

        temporaryFilePathList = []

        # print(
        #     'ClingoInterface: jupyterParenthesis: scanning all subfolders of "' + directoryName + '"(folder) recursively for .ipynb')

        try:
            # os.chdir(os.path.join(os.path.abspath("../../")))  # finding the right directory
            files = glob.glob(self.findDirectory(directoryName) + '**/*.ipynb',
                              recursive=True)  # searching all .ipynb recursively
            # print("Found .ipynb Files: " + str(files))
            # files = glob.glob(os.getcwd() + '/**/*.ipynb', recursive=True)  # searching all .ipynb recursively
        except:
            # print(
            #     "ClingoInterface:jnotebookParenthesis: "
            #     "could not find any .ipynb in the given directory, try to set directory manually")
            raise

        for file in files:
            # print("Reading File: ", file)
            fs = open(file, 'r')  # file provides the filename, r stands for read
            # con = fs.read().splitlines()  # splitlines '\n' -> list

            if parenthesis_start in fs.read():
                # print("Found Clingo Parenthesis in File: ", file)

                fs = open(file, 'r')
                con = fs.read().splitlines()  # splitlines '\n' -> list

                for line in con:
                    if parenthesis_end in line:  # checks for the end parenthesis
                        parenthesis = False
                    if parenthesis:  # adds clingo code to to parenthesis_content
                        parenthesis_content += line[5:-2].replace("\\n", "\n").replace('\\"', '"')
                    if parenthesis_start in line:  # checks for start parenthesis
                        parenthesis = True
                self.problems.append(ClingoProblem(parenthesis_content))
                # creating a temporary file for each notebook which contains clingo code
                # fd, temporaryFilePath = tempfile.mkstemp(suffix='.txt', prefix='clingoInterfaceTemp_', dir=os.getcwd(),
                #                                          text=True)

                # detailed documentation: https://docs.python.org/3/library/tempfile.html
                # print("TEMPFILE path: " + temporaryFilePath)

                # with os.fdopen(fd, "w") as tmp:
                #     clingoCodeContent = parenthesis_content.split("\n", 1)[1]
                #     tmp.write(clingoCodeContent)

                # temporaryFilePathList.append(temporaryFilePath)

        return temporaryFilePathList

        # # solution which removes temporary files immediately
        # try:
        #     with os.fdopen(fd, "w") as tmp:
        #         clingoCodeContent = parenthesis_content.split("\n", 1)[1]
        #         tmp.write(clingoCodeContent)
        #
        #     # running the clingo code in the temporary files
        #     ClingoInterface.run(self, temporaryFilePath)
        #     return
        #
        #     tmp.close()
        #
        # finally:
        #     os.remove(temporaryFilePath)

        # TODO: run/execute seperately and not directly after creating tempfile,
        #  adding strings to temp files after creation, user friendlier solution?
        #  when are we deleting the tempfiles?


# interface = ClingoInterface()
# pathList = interface.jupyterParenthesis()
# interface.problems[0].run()
# print(interface.problems[0].solutions.solutions)
