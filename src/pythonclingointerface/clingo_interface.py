import subprocess
import os
import tempfile
import glob
import ipynbname
import random
from typing import List

#TODO: output errors and stats of clingo code when printing solutions, there is no way for debugging bad clingo code from jupyter

class ClingoSolution:
    """
    Solution Format
    """

    def __init__(self, p_text):
        self.solutions = []
        self.text = p_text
        self.go = False
        lines = self.text.splitlines()
        for line in lines:
            if self.go:
                self.solutions.append([])
                for part in line.decode("utf-8").split(" "):
                    self.solutions[len(self.solutions) - 1].append(part)
                self.go = False
            if "Answer" in line.decode("utf-8"):
                self.go = True
        self.text = self.text.decode("utf-8")


class ClingoProblem:
    """
    calls executeClingoCode, can take lists of code or a single code file
    """

    def __init__(self, autoexe=True, clingoString="<CLINGO\n\n\n\nCLINGO>", name="Problem Name"):
        self.solution: ClingoSolution
        self.name = name
        self.problemCode = clingoString
        self.setName()
        if (autoexe):
            self.executeClingoCode()

    def addRelation(self, clauseName, clauseObject, clauseSubject):
        temp = self.problemCode.split("\n")
        insert = clauseName + "(" + clauseObject + "," + clauseSubject + ")."
        temp = [temp[0], temp[1], insert] + temp[2:]
        self.problemCode = "\n".join(temp)

    def addFact(self, clauseName, clauseObject):
        temp = self.problemCode.split("\n")
        insert = clauseName + "(" + clauseObject + ")."
        temp = [temp[0], temp[1], insert] + temp[2:]
        self.problemCode = "\n".join(temp)

    def addClause(self, clauseText):
        temp = self.problemCode.split("\n")
        temp = [temp[0], temp[1], clauseText] + temp[2:]
        self.problemCode = "\n".join(temp)

    def executeClingoCode(self):
        """
        executes clingo code inside a subprocess(in a terminal) and adds the solutions to the ClingoSolutions Class
        """
        fd, temporaryFilePath = tempfile.mkstemp(suffix='.txt', prefix='clingoInterfaceTemp_', dir=os.getcwd(),
                                                 text=True)
        with os.fdopen(fd, "w") as tmp:
            clingoCodeContent = self.problemCode.split("\n", 1)

            if len(clingoCodeContent) > 1:
                clingoCodeContent = clingoCodeContent[1]
            else:
                return
            tmp.write(clingoCodeContent)

        if temporaryFilePath is not None:
            with tempfile.TemporaryFile() as tempf:
                proc = subprocess.Popen('clingo ' + temporaryFilePath + " 0", shell=True, stdout=tempf) # 0 shows all solutions in clingo
                proc.wait()
                tempf.seek(0)
                self.solution = ClingoSolution(tempf.read())

        else:
            print("ClingoInterface:Run(): there is no file to run")
        os.remove(temporaryFilePath)

    def setName(self, name=None):
        """
        Sets a new name for the ClingoProblem
        """
        if(name==None):
            tmpContent=self.problemCode.split("\n")
            tmpContent=tmpContent[:2]
            for line in tmpContent:
                if(line.startswith("%")):
                    self.name=line.strip("%")
                    return
            self.name="Unknown"
            return
        else:
            self.name = name
            return


class ClingoInterface:
    """
    calls executeClingoCode, can take lists of code or a single code file
    """

    def __init__(self, debug=False):
        self.debug=debug
        self.problems:List[ClingoProblem]= []
        if self.debug:
            print("TestID: \n"+str(random.randint(0,500)))

    def printSolutions(self):
        """
        printing ALL solutions generated by Run()->ClingoSolutions
        """

        print(self.problems)
        for i in self.problems:
            print(i.name)
            print(i.solution.solutions)

    def run(self, pathList_or_code):
        """
        calls executeClingoCode, can take lists of code or a single code file
        """

        if type(pathList_or_code) is list:
            for path in pathList_or_code:
                self.executeClingoCode(path)
        else:
            self.executeClingoCode(pathList_or_code)

    def getSolutions(self):
        """
        returns solutions as a dictionary
        """
        solutionDict = dict()
        for i in self.problems:

            solutionDict[i.name] = i.solution.solutions

        return solutionDict

    def findDirectory(self, foldername):
        """
        scans all folders and looks for a match with the given foldername
        if it finds the folder it returns the path
        example:
        findDirectory(test)
        absolutepath: C:\\Users\\USER\\test\\Project\\helloworld.txt
        returns: C:\\Users\\USER\\test\\
        """
        sep = os.sep
        dirs = os.path.abspath("").split("\\")
        newdir = ""
        for d in dirs:
            # print(d)
            newdir += d + sep
            if d == foldername:
                return newdir
    def nameToIndex(self,name):
        if(self.problems != None):
            for i in range(len(self.problems)):
                if self.problems[i].name.startswith(name):
                    return i
        return -1
    def checkParenthesis(self, directoryName="None", debug=False, py=True, txt=True, ipynb=True, autoexecute=True, concatenate=0):
        """

        scanning all directories recursively for jupyter notebook files
        extracting the (clingo) code between 2 markers/parenthesis (perenthesis_start & parenthesis_end)

        :param directoryName:
        :param filePath:
        :param py:
        :param txt:
        :param ipynb:
        :return:
        """
        parenthesis = False
        parenthesis_start = "<CLINGO"
        parenthesis_end = "CLINGO>"
        parenthesis_content = ""
        files = []

        # if no foldername is given, clingoParenthesis will try to work with the .ipynb it was called from
        if directoryName == "None":
            try:
                currentNotebookName = ipynbname.name()
                currentNotebookPath = str(ipynbname.path())
                if debug:
                    print("ClingoInterface: scanning " + currentNotebookName + ".ipynb")
                files.append(currentNotebookPath)
                if debug:
                    print(files)

            except:
                if debug:
                    print(
                        "ClingoInterface: checkParenthesis: could not read the current file")

        else:
            if debug:
                print(
                    'ClingoInterface: checkParenthesis: scanning all subfolders of "' + directoryName + '"(folder) recursively for .ipynb')

            potential_files = self.findDirectory(directoryName)
            try:
                if py:
                    files.extend(glob.glob(potential_files + '**/*.py', recursive=True))
                if txt:
                    files.extend(glob.glob(potential_files + '**/*.txt', recursive=True))
                if ipynb:
                    files.extend(glob.glob(potential_files + '**/*.ipynb', recursive=True))
                if debug:
                    print("Found .ipynb Files: " + str(files))
            except:
                if debug:
                    print(
                    "ClingoInterface:jnotebookParenthesis: could not find any .ipynb in the given directory, try to set directory manually")

        for file in files:
            if debug:
                print("Reading File: ", file)
            fs = open(file, 'r')
            if parenthesis_start in fs.read():
                if debug:
                    print("Found Clingo Parenthesis in File: ", file)
                fs = open(file, 'r')
                con = fs.read().splitlines()  # splitlines '\n' -> list
                for line in con:
                    if parenthesis_end in line:  # checks for the end parenthesis
                        parenthesis = False
                        if(concatenate==0 or concatenate==2):
                            self.problems.append(ClingoProblem(clingoString=parenthesis_content, autoexe=autoexecute))
                            if(concatenate==0):
                                parenthesis_content=""
                    if parenthesis:  # adds clingo code to to parenthesis_content
                        parenthesis_content += line[5:-2].replace("\\n", "\n").replace('\\"', '"').replace("\\\\","\\")
                    if parenthesis_start in line:  # checks for start parenthesis
                        parenthesis = True
                if concatenate==1:
                    self.problems.append(ClingoProblem(clingoString=parenthesis_content,autoexe=autoexecute))

