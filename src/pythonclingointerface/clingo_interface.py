import subprocess
import os
import tempfile
import glob
import ipynbname


#TODO: output errors and stats of clingo code when printing solutions, there is no way for debugging bad clingo code from jupyter

class ClingoSolution:
    """
    Solution Format
    """

    def __init__(self, p_text):
        self.solutions = []
        self.text = p_text
        self.go = False
        lines = self.text.splitlines()
        for line in lines:
            if self.go:
                self.solutions.append([])
                for part in line.decode("utf-8").split(" "):
                    self.solutions[len(self.solutions) - 1].append(part)
                self.go = False
            if "Answer" in line.decode("utf-8"):
                self.go = True
        self.text = self.text.decode("utf-8")


class ClingoProblem:
    """
    calls executeClingoCode, can take lists of code or a single code file
    """

    def __init__(self, tmpFile=None, autoexecute=True, clingoString=None, name="Problem Name"):
        self.solution: ClingoSolution
        self.name = name
        self.path = tmpFile
        self.problemCode = clingoString

        if (autoexecute):
            self.executeClingoCode()
            if (clingoString and tmpFile == None):
                fd, tmpFile = tempfile.mkstemp(suffix='.txt', prefix='clingoInterfaceTemp_', dir=os.getcwd(), text=True)
                with os.fdopen(fd, "w") as tmp:
                    tmp.write(clingoString)
                self.executeClingoCode()
                os.remove(tmpFile)

    def executeClingoCode(self):
        """
        executes clingo code inside a subprocess(in a terminal) and adds the solutions to the ClingoSolutions Class
        """

        if self.path is not None:
            with tempfile.TemporaryFile() as tempf:
                proc = subprocess.Popen('clingo ' + self.path + " 0", shell=True, stdout=tempf) # 0 shows all solutions in clingo
                proc.wait()
                tempf.seek(0)
                self.solution = ClingoSolution(tempf.read())
        else:
            print("ClingoInterface:Run(): there is no file to run")

    def setName(self, name):
        """
        Sets a new name for the ClingoProblem
        """
        self.name = name


class ClingoInterface:
    """
    calls executeClingoCode, can take lists of code or a single code file
    """

    def __init__(self):
        self.problems = []

    def printSolutions(self):
        """
        printing ALL solutions generated by Run()->ClingoSolutions
        """

        print(self.problems)
        for i in self.problems:
            print(i.name)
            print(i.solution.solutions)

    def run(self, pathList_or_code):
        """
        calls executeClingoCode, can take lists of code or a single code file
        """

        if type(pathList_or_code) is list:
            for path in pathList_or_code:
                self.executeClingoCode(path)
        else:
            self.executeClingoCode(pathList_or_code)

    def findDirectory(self, foldername):
        """
        scans all folders and looks for a match with the given foldername
        if it finds the folder it returns the path
        example:
        findDirectory(test)
        absolutepath: C:\\Users\\USER\\test\\Project\\helloworld.txt
        returns: C:\\Users\\USER\\test\\
        """
        sep = os.sep
        dirs = os.path.abspath("").split("\\")
        newdir = ""
        for d in dirs:
            # print(d)
            newdir += d + sep
            if d == foldername:
                return newdir

    def checkParenthesis(self, directoryName="None", py=True, txt=True, ipynb=True):
        """

        scanning all directories recursively for jupyter notebook files
        extracting the (clingo) code between 2 markers/parenthesis (perenthesis_start & parenthesis_end)

        :param directoryName:
        :param filePath:
        :param py:
        :param txt:
        :param ipynb:
        :return:
        """
        parenthesis = False
        parenthesis_start = "<CLINGO"
        parenthesis_end = "CLINGO>"
        parenthesis_content = ""
        files = []

        # if no foldername is given, clingoParenthesis will try to work with the .ipynb it was called from
        if directoryName == "None":
            try:
                currentNotebookName = ipynbname.name()
                currentNotebookPath = str(ipynbname.path())
                print("ClingoInterface: scanning " + currentNotebookName + ".ipynb")
                files.append(currentNotebookPath)
                print(files)

            except:
                print(
                    "ClingoInterface: checkParenthesis: could not read the current file")

        else:
            print(
                'ClingoInterface: checkParenthesis: scanning all subfolders of "' + directoryName + '"(folder) recursively for .ipynb')

            potential_files = self.findDirectory(directoryName)
            try:
                if py:
                    files.extend(glob.glob(potential_files + '**/*.py', recursive=True))
                if txt:
                    files.extend(glob.glob(potential_files + '**/*.txt', recursive=True))
                if ipynb:
                    files.extend(glob.glob(potential_files + '**/*.ipynb', recursive=True))

                print("Found .ipynb Files: " + str(files))
            except:
                print(
                    "ClingoInterface:jnotebookParenthesis: could not find any .ipynb in the given directory, try to set directory manually")

        for file in files:
            print("Reading File: ", file)
            fs = open(file, 'r')
            if parenthesis_start in fs.read():
                print("Found Clingo Parenthesis in File: ", file)
                fs = open(file, 'r')
                con = fs.read().splitlines()  # splitlines '\n' -> list
                for line in con:
                    if parenthesis_end in line:  # checks for the end parenthesis
                        parenthesis = False
                    if parenthesis:  # adds clingo code to to parenthesis_content
                        parenthesis_content += line[5:-2].replace("\\n", "\n").replace('\\"', '"')
                    if parenthesis_start in line:  # checks for start parenthesis
                        parenthesis = True
                fd, temporaryFilePath = tempfile.mkstemp(suffix='.txt', prefix='clingoInterfaceTemp_', dir=os.getcwd(),
                                                         text=True)
                with os.fdopen(fd, "w") as tmp:
                    print(parenthesis_content)
                    clingoCodeContent = parenthesis_content.split("\n", 1)
                    if len(clingoCodeContent) > 1:
                        clingoCodeContent = clingoCodeContent[1]
                    else:
                        return
                    tmp.write(clingoCodeContent)
                self.problems.append(ClingoProblem(temporaryFilePath))
                os.remove(temporaryFilePath)
